unsigned char _52_describe_sql[19320] = {
"CREATE FUNCTION sys.describe_type(ctype string, digits integer, tscale integer)\n"
"  RETURNS string\n"
"BEGIN\n"
"  RETURN\n"
"    CASE ctype\n"
"      WHEN 'bigint' THEN 'BIGINT'\n"
"      WHEN 'blob' THEN\n"
"	CASE digits\n"
"	  WHEN 0 THEN 'BINARY LARGE OBJECT'\n"
"	  ELSE 'BINARY LARGE OBJECT(' || digits || ')'\n"
"	END\n"
"      WHEN 'boolean' THEN 'BOOLEAN'\n"
"      WHEN 'char' THEN\n"
"        CASE digits\n"
"          WHEN 1 THEN 'CHARACTER'\n"
"          ELSE 'CHARACTER(' || digits || ')'\n"
"        END\n"
"      WHEN 'clob' THEN\n"
"	CASE digits\n"
"	  WHEN 0 THEN 'CHARACTER LARGE OBJECT'\n"
"	  ELSE 'CHARACTER LARGE OBJECT(' || digits || ')'\n"
"	END\n"
"      WHEN 'date' THEN 'DATE'\n"
"      WHEN 'day_interval' THEN 'INTERVAL DAY'\n"
"      WHEN ctype = 'decimal' THEN\n"
"  	CASE\n"
"	  WHEN (digits = 1 AND tscale = 0) OR digits = 0 THEN 'DECIMAL'\n"
"	  WHEN tscale = 0 THEN 'DECIMAL(' || digits || ')'\n"
"	  WHEN digits = 39 THEN 'DECIMAL(' || 38 || ',' || tscale || ')'\n"
"	  WHEN digits = 19 AND (SELECT COUNT(*) = 0 FROM sys.types WHERE sqlname = 'hugeint' ) THEN 'DECIMAL(' || 18 || ',' || tscale || ')'\n"
"	  ELSE 'DECIMAL(' || digits || ',' || tscale || ')'\n"
"	END\n"
"      WHEN 'double' THEN\n"
"	CASE\n"
"	  WHEN digits = 53 and tscale = 0 THEN 'DOUBLE'\n"
"	  WHEN tscale = 0 THEN 'FLOAT(' || digits || ')'\n"
"	  ELSE 'FLOAT(' || digits || ',' || tscale || ')'\n"
"	END\n"
"      WHEN 'geometry' THEN\n"
"	CASE digits\n"
"	  WHEN 4 THEN 'GEOMETRY(POINT' ||\n"
"            CASE tscale\n"
"              WHEN 0 THEN ''\n"
"              ELSE ',' || tscale\n"
"            END || ')'\n"
"	  WHEN 8 THEN 'GEOMETRY(LINESTRING' ||\n"
"            CASE tscale\n"
"              WHEN 0 THEN ''\n"
"              ELSE ',' || tscale\n"
"            END || ')'\n"
"	  WHEN 16 THEN 'GEOMETRY(POLYGON' ||\n"
"            CASE tscale\n"
"              WHEN 0 THEN ''\n"
"              ELSE ',' || tscale\n"
"            END || ')'\n"
"	  WHEN 20 THEN 'GEOMETRY(MULTIPOINT' ||\n"
"            CASE tscale\n"
"              WHEN 0 THEN ''\n"
"              ELSE ',' || tscale\n"
"            END || ')'\n"
"	  WHEN 24 THEN 'GEOMETRY(MULTILINESTRING' ||\n"
"            CASE tscale\n"
"              WHEN 0 THEN ''\n"
"              ELSE ',' || tscale\n"
"            END || ')'\n"
"	  WHEN 28 THEN 'GEOMETRY(MULTIPOLYGON' ||\n"
"            CASE tscale\n"
"              WHEN 0 THEN ''\n"
"              ELSE ',' || tscale\n"
"            END || ')'\n"
"	  WHEN 32 THEN 'GEOMETRY(GEOMETRYCOLLECTION' ||\n"
"            CASE tscale\n"
"              WHEN 0 THEN ''\n"
"              ELSE ',' || tscale\n"
"            END || ')'\n"
"	  ELSE 'GEOMETRY'\n"
"        END\n"
"      WHEN 'hugeint' THEN 'HUGEINT'\n"
"      WHEN 'int' THEN 'INTEGER'\n"
"      WHEN 'month_interval' THEN\n"
"	CASE digits\n"
"	  WHEN 1 THEN 'INTERVAL YEAR'\n"
"	  WHEN 2 THEN 'INTERVAL YEAR TO MONTH'\n"
"	  WHEN 3 THEN 'INTERVAL MONTH'\n"
"	END\n"
"      WHEN 'real' THEN\n"
"	CASE\n"
"	  WHEN digits = 24 and tscale = 0 THEN 'REAL'\n"
"	  WHEN tscale = 0 THEN 'FLOAT(' || digits || ')'\n"
"	  ELSE 'FLOAT(' || digits || ',' || tscale || ')'\n"
"	END\n"
"      WHEN 'sec_interval' THEN\n"
"	CASE digits\n"
"	  WHEN 4 THEN 'INTERVAL DAY'\n"
"	  WHEN 5 THEN 'INTERVAL DAY TO HOUR'\n"
"	  WHEN 6 THEN 'INTERVAL DAY TO MINUTE'\n"
"	  WHEN 7 THEN 'INTERVAL DAY TO SECOND'\n"
"	  WHEN 8 THEN 'INTERVAL HOUR'\n"
"	  WHEN 9 THEN 'INTERVAL HOUR TO MINUTE'\n"
"	  WHEN 10 THEN 'INTERVAL HOUR TO SECOND'\n"
"	  WHEN 11 THEN 'INTERVAL MINUTE'\n"
"	  WHEN 12 THEN 'INTERVAL MINUTE TO SECOND'\n"
"	  WHEN 13 THEN 'INTERVAL SECOND'\n"
"	END\n"
"      WHEN 'smallint' THEN 'SMALLINT'\n"
"      WHEN 'time' THEN\n"
"	CASE digits\n"
"	  WHEN 1 THEN 'TIME'\n"
"	  ELSE 'TIME(' || (digits - 1) || ')'\n"
"	END\n"
"      WHEN 'timestamp' THEN\n"
"	CASE digits\n"
"	  WHEN 7 THEN 'TIMESTAMP'\n"
"	  ELSE 'TIMESTAMP(' || (digits - 1) || ')'\n"
"	END\n"
"      WHEN 'timestamptz' THEN\n"
"	CASE digits\n"
"	  WHEN 7 THEN 'TIMESTAMP'\n"
"	  ELSE 'TIMESTAMP(' || (digits - 1) || ')'\n"
"	END || ' WITH TIME ZONE'\n"
"      WHEN 'timetz' THEN\n"
"	CASE digits\n"
"	  WHEN 1 THEN 'TIME'\n"
"	  ELSE 'TIME(' || (digits - 1) || ')'\n"
"	END || ' WITH TIME ZONE'\n"
"      WHEN 'tinyint' THEN 'TINYINT'\n"
"      WHEN 'varchar' THEN 'CHARACTER VARYING(' || digits || ')'\n"
"      ELSE\n"
"        CASE\n"
"          WHEN lower(ctype) = ctype THEN upper(ctype)\n"
"          ELSE '\"' || ctype || '\"'\n"
"        END || CASE digits\n"
"	  WHEN 0 THEN ''\n"
"          ELSE '(' || digits || CASE tscale\n"
"	    WHEN 0 THEN ''\n"
"            ELSE ',' || tscale\n"
"          END || ')'\n"
"	END\n"
"    END;\n"
"END;\n"
"CREATE FUNCTION sys.SQ (s STRING) RETURNS STRING BEGIN RETURN '''' || sys.replace(s,'''','''''') || ''''; END;\n"
"CREATE FUNCTION sys.DQ (s STRING) RETURNS STRING BEGIN RETURN '\"' || sys.replace(s,'\"','\"\"') || '\"'; END;\n"
"CREATE FUNCTION sys.FQN(s STRING, t STRING) RETURNS STRING BEGIN RETURN '\"' || sys.replace(s,'\"','\"\"') || '\".\"' || sys.replace(t,'\"','\"\"') || '\"'; END;\n"
"CREATE FUNCTION sys.schema_guard(sch STRING, nme STRING, stmt STRING) RETURNS STRING BEGIN\n"
"RETURN\n"
"	SELECT 'SET SCHEMA ' || sys.dq(sch) || '; ' || stmt;\n"
"END;\n"
"CREATE VIEW sys.describe_constraints AS\n"
"	SELECT\n"
"		s.name sch,\n"
"		t.name tbl,\n"
"		kc.name col,\n"
"		k.name con,\n"
"		CASE k.type WHEN 0 THEN 'PRIMARY KEY' WHEN 1 THEN 'UNIQUE' END tpe\n"
"	FROM sys.schemas s, sys._tables t, sys.objects kc, sys.keys k\n"
"	WHERE kc.id = k.id\n"
"		AND k.table_id = t.id\n"
"		AND s.id = t.schema_id\n"
"		AND t.system = FALSE\n"
"		AND k.type in (0, 1);\n"
"CREATE VIEW sys.describe_indices AS\n"
"	WITH it (id, idx) AS (VALUES (0, 'INDEX'), (4, 'IMPRINTS INDEX'), (5, 'ORDERED INDEX'))\n"
"	SELECT\n"
"		i.name ind,\n"
"		s.name sch,\n"
"		t.name tbl,\n"
"		c.name col,\n"
"		it.idx tpe\n"
"	FROM\n"
"		sys.idxs AS i LEFT JOIN sys.keys AS k ON i.name = k.name,\n"
"		sys.objects AS kc,\n"
"		sys._columns AS c,\n"
"		sys.schemas s,\n"
"		sys._tables AS t,\n"
"		it\n"
"	WHERE\n"
"		i.table_id = t.id\n"
"		AND i.id = kc.id\n"
"		AND kc.name = c.name\n"
"		AND t.id = c.table_id\n"
"		AND t.schema_id = s.id\n"
"		AND k.type IS NULL\n"
"		AND i.type = it.id\n"
"	ORDER BY i.name, kc.nr;\n"
"CREATE VIEW sys.describe_column_defaults AS\n"
"	SELECT\n"
"		s.name sch,\n"
"		t.name tbl,\n"
"		c.name col,\n"
"		c.\"default\" def\n"
"	FROM sys.schemas s, sys.tables t, sys.columns c\n"
"	WHERE\n"
"		s.id = t.schema_id AND\n"
"		t.id = c.table_id AND\n"
"		s.name <> 'tmp' AND\n"
"		NOT t.system AND\n"
"		c.\"default\" IS NOT NULL;\n"
"CREATE VIEW sys.describe_foreign_keys AS\n"
"		WITH action_type (id, act) AS (VALUES\n"
"			(0, 'NO ACTION'),\n"
"			(1, 'CASCADE'),\n"
"			(2, 'RESTRICT'),\n"
"			(3, 'SET NULL'),\n"
"			(4, 'SET DEFAULT'))\n"
"		SELECT\n"
"			fs.name fk_s,\n"
"			fkt.name fk_t,\n"
"			fkkc.name fk_c,\n"
"			fkkc.nr o,\n"
"			fkk.name fk,\n"
"			ps.name pk_s,\n"
"			pkt.name pk_t,\n"
"			pkkc.name pk_c,\n"
"			ou.act on_update,\n"
"			od.act on_delete\n"
"		FROM sys._tables fkt,\n"
"			sys.objects fkkc,\n"
"			sys.keys fkk,\n"
"			sys._tables pkt,\n"
"			sys.objects pkkc,\n"
"			sys.keys pkk,\n"
"			sys.schemas ps,\n"
"			sys.schemas fs,\n"
"			action_type ou,\n"
"			action_type od\n"
"		WHERE fkt.id = fkk.table_id\n"
"		AND pkt.id = pkk.table_id\n"
"		AND fkk.id = fkkc.id\n"
"		AND pkk.id = pkkc.id\n"
"		AND fkk.rkey = pkk.id\n"
"		AND fkkc.nr = pkkc.nr\n"
"		AND pkt.schema_id = ps.id\n"
"		AND fkt.schema_id = fs.id\n"
"		AND (fkk.\"action\" & 255)         = od.id\n"
"		AND ((fkk.\"action\" >> 8) & 255)  = ou.id\n"
"		ORDER BY fkk.name, fkkc.nr;\n"
"CREATE FUNCTION sys.get_merge_table_partition_expressions(tid INT) RETURNS STRING\n"
"BEGIN\n"
"	RETURN\n"
"		SELECT\n"
"			CASE WHEN tp.table_id IS NOT NULL THEN\n"
"				' PARTITION BY ' ||\n"
"				ifthenelse(bit_and(tp.type, 2) = 2, 'VALUES ', 'RANGE ') ||\n"
"				CASE\n"
"					WHEN bit_and(tp.type, 4) = 4\n"
"					THEN 'ON ' || '(' || (SELECT sys.DQ(c.name) || ')' FROM sys.columns c WHERE c.id = tp.column_id)\n"
"					ELSE 'USING ' || '(' || tp.expression || ')'\n"
"				END\n"
"			ELSE\n"
"				''\n"
"			END\n"
"		FROM (VALUES (tid)) t(id) LEFT JOIN sys.table_partitions tp ON t.id = tp.table_id;\n"
"END;\n"
"CREATE FUNCTION sys.get_remote_table_expressions(s STRING, t STRING) RETURNS STRING BEGIN\n"
"	RETURN SELECT ' ON ' || sys.SQ(uri) || ' WITH USER ' || sys.SQ(username) || ' ENCRYPTED PASSWORD ' || sys.SQ(\"hash\") FROM sys.remote_table_credentials(s ||'.' || t);\n"
"END;\n"
"CREATE VIEW sys.describe_tables AS\n"
"	SELECT\n"
"		t.id o,\n"
"		s.name sch,\n"
"		t.name tab,\n"
"		ts.table_type_name typ,\n"
"		(SELECT\n"
"			' (' ||\n"
"			GROUP_CONCAT(\n"
"				sys.DQ(c.name) || ' ' ||\n"
"				sys.describe_type(c.type, c.type_digits, c.type_scale) ||\n"
"				ifthenelse(c.\"null\" = 'false', ' NOT NULL', '')\n"
"			, ', ') || ')'\n"
"		FROM sys._columns c\n"
"		WHERE c.table_id = t.id) col,\n"
"		CASE ts.table_type_name\n"
"			WHEN 'REMOTE TABLE' THEN\n"
"				sys.get_remote_table_expressions(s.name, t.name)\n"
"			WHEN 'MERGE TABLE' THEN\n"
"				sys.get_merge_table_partition_expressions(t.id)\n"
"			WHEN 'VIEW' THEN\n"
"				sys.schema_guard(s.name, t.name, t.query)\n"
"			ELSE\n"
"				''\n"
"		END opt\n"
"	FROM sys.schemas s, sys.table_types ts, sys.tables t\n"
"	WHERE ts.table_type_name IN ('TABLE', 'VIEW', 'MERGE TABLE', 'REMOTE TABLE', 'REPLICA TABLE', 'UNLOGGED TABLE')\n"
"		AND t.system = FALSE\n"
"		AND s.id = t.schema_id\n"
"		AND ts.table_type_id = t.type\n"
"		AND s.name <> 'tmp';\n"
"CREATE VIEW sys.describe_triggers AS\n"
"		SELECT\n"
"			s.name sch,\n"
"			t.name tab,\n"
"			tr.name tri,\n"
"			tr.statement def\n"
"		FROM sys.schemas s, sys.tables t, sys.triggers tr\n"
"		WHERE s.id = t.schema_id AND t.id = tr.table_id AND NOT t.system;\n"
"CREATE VIEW sys.fully_qualified_functions AS\n"
"	WITH fqn(id, tpe, sig, num) AS\n"
"	(\n"
"		SELECT\n"
"			f.id,\n"
"			ft.function_type_keyword,\n"
"			CASE WHEN a.type IS NULL THEN\n"
"				sys.fqn(s.name, f.name) || '()'\n"
"			ELSE\n"
"				sys.fqn(s.name, f.name) || '(' || group_concat(sys.describe_type(a.type, a.type_digits, a.type_scale), ',') OVER (PARTITION BY f.id ORDER BY a.number)  || ')'\n"
"			END,\n"
"			a.number\n"
"		FROM sys.schemas s, sys.function_types ft, sys.functions f LEFT JOIN sys.args a ON f.id = a.func_id\n"
"		WHERE s.id= f.schema_id AND f.type = ft.function_type_id\n"
"	)\n"
"	SELECT\n"
"		fqn1.id id,\n"
"		fqn1.tpe tpe,\n"
"		fqn1.sig nme\n"
"	FROM\n"
"		fqn fqn1 JOIN (SELECT id, max(num) FROM fqn GROUP BY id)  fqn2(id, num)\n"
"		ON fqn1.id = fqn2.id AND (fqn1.num = fqn2.num OR fqn1.num IS NULL AND fqn2.num is NULL);\n"
"CREATE VIEW sys.describe_comments AS\n"
"		SELECT\n"
"			o.id id,\n"
"			o.tpe tpe,\n"
"			o.nme fqn,\n"
"			c.remark rem\n"
"		FROM (\n"
"			SELECT id, 'SCHEMA', sys.DQ(name) FROM sys.schemas\n"
"			UNION ALL\n"
"			SELECT t.id, ifthenelse(ts.table_type_name = 'VIEW', 'VIEW', 'TABLE'), sys.FQN(s.name, t.name)\n"
"			FROM sys.schemas s JOIN sys.tables t ON s.id = t.schema_id JOIN sys.table_types ts ON t.type = ts.table_type_id\n"
"			WHERE s.name <> 'tmp'\n"
"			UNION ALL\n"
"			SELECT c.id, 'COLUMN', sys.FQN(s.name, t.name) || '.' || sys.DQ(c.name) FROM sys.columns c, sys.tables t, sys.schemas s WHERE c.table_id = t.id AND t.schema_id = s.id\n"
"			UNION ALL\n"
"			SELECT idx.id, 'INDEX', sys.FQN(s.name, idx.name) FROM sys.idxs idx, sys._tables t, sys.schemas s WHERE idx.table_id = t.id AND t.schema_id = s.id\n"
"			UNION ALL\n"
"			SELECT seq.id, 'SEQUENCE', sys.FQN(s.name, seq.name) FROM sys.sequences seq, sys.schemas s WHERE seq.schema_id = s.id\n"
"			UNION ALL\n"
"			SELECT f.id, ft.function_type_keyword, qf.nme FROM sys.functions f, sys.function_types ft, sys.schemas s, sys.fully_qualified_functions qf WHERE f.type = ft.function_type_id AND f.schema_id = s.id AND qf.id = f.id\n"
"			) AS o(id, tpe, nme)\n"
"			JOIN sys.comments c ON c.id = o.id;\n"
"CREATE VIEW sys.describe_privileges AS\n"
"	SELECT\n"
"		CASE\n"
"			WHEN o.tpe IS NULL AND pc.privilege_code_name = 'SELECT' THEN\n"
"				'COPY FROM'\n"
"			WHEN o.tpe IS NULL AND pc.privilege_code_name = 'UPDATE' THEN\n"
"				'COPY INTO'\n"
"			ELSE\n"
"				o.nme\n"
"		END o_nme,\n"
"		coalesce(o.tpe, 'GLOBAL') o_tpe,\n"
"		pc.privilege_code_name p_nme,\n"
"		a.name a_nme,\n"
"		g.name g_nme,\n"
"		p.grantable grantable\n"
"	FROM\n"
"		sys.privileges p LEFT JOIN\n"
"		(\n"
"		SELECT t.id, s.name || '.' || t.name , 'TABLE'\n"
"			from sys.schemas s, sys.tables t where s.id = t.schema_id\n"
"		UNION ALL\n"
"			SELECT c.id, s.name || '.' || t.name || '.' || c.name, 'COLUMN'\n"
"			FROM sys.schemas s, sys.tables t, sys.columns c where s.id = t.schema_id AND t.id = c.table_id\n"
"		UNION ALL\n"
"			SELECT f.id, f.nme, f.tpe\n"
"			FROM sys.fully_qualified_functions f\n"
"		) o(id, nme, tpe) ON o.id = p.obj_id,\n"
"		sys.privilege_codes pc,\n"
"		auths a, auths g\n"
"	WHERE\n"
"		p.privileges = pc.privilege_code_id AND\n"
"		p.auth_id = a.id AND\n"
"		p.grantor = g.id;\n"
"CREATE FUNCTION sys.describe_table(schemaName string, tableName string)\n"
"  RETURNS TABLE(name string, query string, type string, id integer, remark string)\n"
"BEGIN\n"
"	RETURN SELECT t.name, t.query, tt.table_type_name, t.id, c.remark\n"
"		FROM sys.schemas s, sys.table_types tt, sys._tables t\n"
"		LEFT OUTER JOIN sys.comments c ON t.id = c.id\n"
"			WHERE s.name = schemaName\n"
"			AND t.schema_id = s.id\n"
"			AND t.name = tableName\n"
"			AND t.type = tt.table_type_id;\n"
"END;\n"
"CREATE VIEW sys.describe_user_defined_types AS\n"
"	SELECT\n"
"		s.name sch,\n"
"		t.sqlname sql_tpe,\n"
"		t.systemname ext_tpe\n"
"	FROM sys.types t JOIN sys.schemas s ON t.schema_id = s.id\n"
"	WHERE\n"
"		t.eclass = 18 AND\n"
"		(\n"
"			(s.name = 'sys' AND t.sqlname not in ('geometrya', 'mbr', 'url', 'inet', 'json', 'uuid', 'xml')) OR\n"
"			(s.name <> 'sys')\n"
"		);\n"
"CREATE VIEW sys.describe_partition_tables AS\n"
"	SELECT\n"
"		m_sch,\n"
"		m_tbl,\n"
"		p_sch,\n"
"		p_tbl,\n"
"		CASE\n"
"			WHEN p_raw_type IS NULL THEN 'READ ONLY'\n"
"			WHEN (p_raw_type = 'VALUES' AND pvalues IS NULL) OR (p_raw_type = 'RANGE' AND minimum IS NULL AND maximum IS NULL AND with_nulls) THEN 'FOR NULLS'\n"
"			ELSE p_raw_type\n"
"		END AS tpe,\n"
"		pvalues,\n"
"		minimum,\n"
"		maximum,\n"
"		with_nulls\n"
"	FROM\n"
"	(WITH\n"
"		tp(\"type\", table_id) AS\n"
"		(SELECT ifthenelse((table_partitions.\"type\" & 2) = 2, 'VALUES', 'RANGE'), table_partitions.table_id FROM sys.table_partitions),\n"
"		subq(m_tid, p_mid, \"type\", m_sch, m_tbl, p_sch, p_tbl) AS\n"
"		(SELECT m_t.id, p_m.id, m_t.\"type\", m_s.name, m_t.name, p_s.name, p_m.name\n"
"		FROM sys.schemas m_s, sys._tables m_t, sys.dependencies d, sys.schemas p_s, sys._tables p_m\n"
"		WHERE m_t.\"type\" IN (3, 6)\n"
"			AND m_t.schema_id = m_s.id\n"
"			AND m_s.name <> 'tmp'\n"
"			AND m_t.system = FALSE\n"
"			AND m_t.id = d.depend_id\n"
"			AND d.id = p_m.id\n"
"			AND p_m.schema_id = p_s.id\n"
"		ORDER BY m_t.id, p_m.id),\n"
"		vals(id,vals) as\n"
"		(SELECT vp.table_id, GROUP_CONCAT(vp.value, ',') FROM sys.value_partitions vp GROUP BY vp.table_id)\n"
"	SELECT\n"
"		subq.m_sch,\n"
"		subq.m_tbl,\n"
"		subq.p_sch,\n"
"		subq.p_tbl,\n"
"		tp.\"type\" AS p_raw_type,\n"
"		CASE WHEN tp.\"type\" = 'VALUES'\n"
"			THEN (SELECT vals.vals FROM vals WHERE vals.id = subq.p_mid)\n"
"			ELSE NULL\n"
"		END AS pvalues,\n"
"		CASE WHEN tp.\"type\" = 'RANGE'\n"
"			THEN (SELECT minimum FROM sys.range_partitions rp WHERE rp.table_id = subq.p_mid)\n"
"			ELSE NULL\n"
"		END AS minimum,\n"
"		CASE WHEN tp.\"type\" = 'RANGE'\n"
"			THEN (SELECT maximum FROM sys.range_partitions rp WHERE rp.table_id = subq.p_mid)\n"
"			ELSE NULL\n"
"		END AS maximum,\n"
"		CASE WHEN tp.\"type\" = 'VALUES'\n"
"			THEN EXISTS(SELECT vp.value FROM sys.value_partitions vp WHERE vp.table_id = subq.p_mid AND vp.value IS NULL)\n"
"			ELSE (SELECT rp.with_nulls FROM sys.range_partitions rp WHERE rp.table_id = subq.p_mid)\n"
"		END AS with_nulls\n"
"	FROM\n"
"		subq LEFT OUTER JOIN tp\n"
"		ON subq.m_tid = tp.table_id) AS tmp_pi;\n"
"CREATE VIEW sys.describe_sequences AS\n"
"	SELECT\n"
"		s.name sch,\n"
"		seq.name seq,\n"
"		seq.\"start\" s,\n"
"		get_value_for(s.name, seq.name) rs,\n"
"		seq.\"minvalue\" mi,\n"
"		seq.\"maxvalue\" ma,\n"
"		seq.\"increment\" inc,\n"
"		seq.\"cacheinc\" cache,\n"
"		seq.\"cycle\" cycle,\n"
"		CASE WHEN seq.\"minvalue\" = -9223372036854775807 AND seq.\"increment\" > 0 AND seq.\"start\" =  1 THEN TRUE ELSE FALSE END nomin,\n"
"		CASE WHEN seq.\"maxvalue\" =  9223372036854775807 AND seq.\"increment\" < 0 AND seq.\"start\" = -1 THEN TRUE ELSE FALSE END nomax,\n"
"		CASE\n"
"			WHEN seq.\"minvalue\" = 0 AND seq.\"increment\" > 0 THEN NULL\n"
"			WHEN seq.\"minvalue\" <> -9223372036854775807 THEN seq.\"minvalue\"\n"
"			ELSE\n"
"				CASE\n"
"					WHEN seq.\"increment\" < 0  THEN NULL\n"
"					ELSE CASE WHEN seq.\"start\" = 1 THEN NULL ELSE seq.\"maxvalue\" END\n"
"				END\n"
"		END rmi,\n"
"		CASE\n"
"			WHEN seq.\"maxvalue\" = 0 AND seq.\"increment\" < 0 THEN NULL\n"
"			WHEN seq.\"maxvalue\" <> 9223372036854775807 THEN seq.\"maxvalue\"\n"
"			ELSE\n"
"				CASE\n"
"					WHEN seq.\"increment\" > 0  THEN NULL\n"
"					ELSE CASE WHEN seq.\"start\" = -1 THEN NULL ELSE seq.\"maxvalue\" END\n"
"				END\n"
"		END rma\n"
"	FROM sys.sequences seq, sys.schemas s\n"
"	WHERE s.id = seq.schema_id\n"
"	AND s.name <> 'tmp'\n"
"	ORDER BY s.name, seq.name;\n"
"CREATE VIEW sys.describe_functions AS\n"
"	WITH func_args_all(func_id, number, max_number, func_arg) AS\n"
"	(\n"
"		SELECT\n"
"			func_id,\n"
"			number,\n"
"			max(number) OVER (PARTITION BY func_id ORDER BY number DESC),\n"
"			group_concat(sys.dq(name) || ' ' || sys.describe_type(type, type_digits, type_scale),', ') OVER (PARTITION BY func_id ORDER BY number)\n"
"		FROM sys.args\n"
"		WHERE inout = 1\n"
"	),\n"
"	func_args(func_id, func_arg) AS\n"
"	(\n"
"		SELECT func_id, func_arg\n"
"		FROM func_args_all\n"
"		WHERE number = max_number\n"
"	),\n"
"	func_rets_all(func_id, number, max_number, func_ret, func_ret_type) AS\n"
"	(\n"
"		SELECT\n"
"			func_id,\n"
"			number,\n"
"			max(number) OVER (PARTITION BY func_id ORDER BY number DESC),\n"
"			group_concat(sys.dq(name) || ' ' || sys.describe_type(type, type_digits, type_scale),', ') OVER (PARTITION BY func_id ORDER BY number),\n"
"			group_concat(sys.describe_type(type, type_digits, type_scale),', ') OVER (PARTITION BY func_id ORDER BY number)\n"
"		FROM sys.args\n"
"		WHERE inout = 0\n"
"	),\n"
"	func_rets(func_id, func_ret, func_ret_type) AS\n"
"	(\n"
"		SELECT\n"
"			func_id,\n"
"			func_ret,\n"
"			func_ret_type\n"
"		FROM func_rets_all\n"
"		WHERE number = max_number\n"
"	)\n"
"	SELECT\n"
"		f.id o,\n"
"		s.name sch,\n"
"		f.name fun,\n"
"		CASE WHEN f.language IN (1, 2) THEN f.func ELSE 'CREATE ' || ft.function_type_keyword || ' ' || sys.FQN(s.name, f.name) || '(' || coalesce(fa.func_arg, '') || ')' || CASE WHEN f.type = 5 THEN ' RETURNS TABLE (' || coalesce(fr.func_ret, '') || ')' WHEN f.type IN (1,3) THEN ' RETURNS ' || fr.func_ret_type ELSE '' END || CASE WHEN fl.language_keyword IS NULL THEN '' ELSE ' LANGUAGE ' || fl.language_keyword END || ' ' || f.func END def\n"
"	FROM sys.functions f\n"
"		LEFT OUTER JOIN func_args fa ON fa.func_id = f.id\n"
"		LEFT OUTER JOIN func_rets fr ON fr.func_id = f.id\n"
"		JOIN sys.schemas s ON f.schema_id = s.id\n"
"		JOIN sys.function_types ft ON f.type = ft.function_type_id\n"
"		LEFT OUTER JOIN sys.function_languages fl ON f.language = fl.language_id\n"
"	WHERE s.name <> 'tmp' AND NOT f.system;\n"
"CREATE FUNCTION sys.describe_columns(schemaName string, tableName string)\n"
"	RETURNS TABLE(name string, type string, digits integer, scale integer, Nulls boolean, cDefault string, number integer, sqltype string, remark string)\n"
"BEGIN\n"
"	RETURN SELECT c.name, c.\"type\", c.type_digits, c.type_scale, c.\"null\", c.\"default\", c.number, sys.describe_type(c.\"type\", c.type_digits, c.type_scale), com.remark\n"
"		FROM sys._tables t, sys.schemas s, sys._columns c\n"
"		LEFT OUTER JOIN sys.comments com ON c.id = com.id\n"
"			WHERE c.table_id = t.id\n"
"			AND t.name = tableName\n"
"			AND t.schema_id = s.id\n"
"			AND s.name = schemaName\n"
"		ORDER BY c.number;\n"
"END;\n"
"CREATE FUNCTION sys.describe_function(schemaName string, functionName string)\n"
"	RETURNS TABLE(id integer, name string, type string, language string, remark string)\n"
"BEGIN\n"
"	RETURN SELECT f.id, f.name, ft.function_type_keyword, fl.language_keyword, c.remark\n"
"		FROM sys.functions f\n"
"		JOIN sys.schemas s ON f.schema_id = s.id\n"
"		JOIN sys.function_types ft ON f.type = ft.function_type_id\n"
"		LEFT OUTER JOIN sys.function_languages fl ON f.language = fl.language_id\n"
"		LEFT OUTER JOIN sys.comments c ON f.id = c.id\n"
"		WHERE f.name=functionName AND s.name = schemaName;\n"
"END;\n"
"GRANT SELECT ON sys.describe_constraints TO PUBLIC;\n"
"GRANT SELECT ON sys.describe_indices TO PUBLIC;\n"
"GRANT SELECT ON sys.describe_column_defaults TO PUBLIC;\n"
"GRANT SELECT ON sys.describe_foreign_keys TO PUBLIC;\n"
"GRANT SELECT ON sys.describe_tables TO PUBLIC;\n"
"GRANT SELECT ON sys.describe_triggers TO PUBLIC;\n"
"GRANT SELECT ON sys.describe_comments TO PUBLIC;\n"
"GRANT SELECT ON sys.fully_qualified_functions TO PUBLIC;\n"
"GRANT SELECT ON sys.describe_privileges TO PUBLIC;\n"
"GRANT SELECT ON sys.describe_user_defined_types TO PUBLIC;\n"
"GRANT SELECT ON sys.describe_partition_tables TO PUBLIC;\n"
"GRANT SELECT ON sys.describe_sequences TO PUBLIC;\n"
"GRANT SELECT ON sys.describe_functions TO PUBLIC;\n"
};
#include "monetdb_config.h"
#include "sql_import.h"
#ifdef _MSC_VER
#undef read
#pragma section(".CRT$XCU",read)
#endif
LIB_STARTUP_FUNC(init_52_describe_sql)
{ sql_register("52_describe", _52_describe_sql); }
